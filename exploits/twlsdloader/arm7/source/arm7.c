/*---------------------------------------------------------------------------------

	derived from the default ARM7 core

		Copyright (C) 2005 - 2010
		Michael Noland (joat)
		Jason Rogers (dovoto)
		Dave Murphy (WinterMute)

	This software is provided 'as-is', without any express or implied
	warranty.  In no event will the authors be held liable for any
	damages arising from the use of this software.

	Permission is granted to anyone to use this software for any
	purpose, including commercial applications, and to alter it and
	redistribute it freely, subject to the following restrictions:

	1.	The origin of this software must not be misrepresented; you
		must not claim that you wrote the original software. If you use
		this software in a product, an acknowledgment in the product
		documentation would be appreciated but is not required.

	2.	Altered source versions must be plainly marked as such, and
		must not be misrepresented as being the original software.

	3.	This notice may not be removed or altered from any source
		distribution.

---------------------------------------------------------------------------------*/
#define USETWLSDMMC

#ifdef USELIBNDS
#include <nds.h>
#else
#include <mininds/mininds.h>
#endif
#ifdef WIFIDEBUG
#include <dswifi7.h>
#endif
#include <nds/bios.h>
#include <string.h>
#include <stdio.h>
#ifdef USETWLSDMMC
#include <twlsdmmc/twlsdmmc.h>
#include <twlsdmmc/sdmmc.h>
#include <twlsdmmc/ff.h>

#define NDSFN "/boot.nds"
#endif

#ifndef HWCRYPTO
#include "dsi.h"
#else
#include <twlescrypt/twlescrypt.h>
#endif

#include "common.h"

void memset32(void* buf, int len);

int nds_crypto();

u32 nds_size = 0;

#ifdef USELIBNDS
//---------------------------------------------------------------------------------
void VblankHandler(void) {
//---------------------------------------------------------------------------------
	#ifdef WIFIDEBUG
	Wifi_Update();
	#endif
}
#endif


#ifdef USELIBNDS
//---------------------------------------------------------------------------------
void VcountHandler() {
//---------------------------------------------------------------------------------
	inputGetAndSend();
}
#endif

volatile bool exitflag = false;

#ifdef USELIBNDS
//---------------------------------------------------------------------------------
void powerButtonCB() {
//---------------------------------------------------------------------------------
	exitflag = true;
}
#endif

static vu32 debugprint_done = 0;
void mini_printhandler(u32 data)
{
	debugprint_done = 1;
}

char *fifo_string = (char*)0x023fff00;
void SendFIFOString(char *str)
{
	#ifdef TWLDEBUG
	if(str)
	{
		strncpy(fifo_string, str, 0xff);
	}
	#ifdef USELIBNDS
	fifoSendAddress(FIFO_USER_01, fifo_string);
	while(!fifoCheckValue32(FIFO_USER_01));
	#else
	debugprint_done = 0;
	mininds_sendfifodata(FIFO_USER_01, (u32)fifo_string);
	while(!debugprint_done)
	{
		swiWaitForVBlank();
		swiWaitForVBlank();
		swiWaitForVBlank();
		swiWaitForVBlank();
		if(!debugprint_done)mininds_sendfifodata(FIFO_USER_01, (u32)fifo_string);
	}
	#endif
	#endif
	memset(fifo_string, 0, 0x100);
}

void dumpdata(u32 *adr, int len)
{
	#ifdef TWLDEBUG
	int sz, curi;
	char str[256];
	memset(str, 0, 256);
	sz = len;
	if(sz>7)sz = 7;
	//SendFIFOString("LOG: Dumping 0x04004800 regs:");
	for(curi=0; curi<len; curi+=sz)
	{
		memset(str, 0, 256);
		sprintf(str, "LOG: %08x %08x %08x %08x %08x %08x %08x", adr[curi+0], adr[curi+1], adr[curi+2], adr[curi+3], adr[curi+4], adr[curi+5], adr[curi+6]);
		SendFIFOString(str);
		sz = len-curi;
		if(sz>7)sz = 7;
	}
	#endif
}

int memrange_check(u32 addr, u32 len)
{
	if(len & (0xff<<24))return 1;
	if(addr==0 && len==0)return 0;
	switch(addr>>24)
	{
		case 0x02:
			if(addr>=0x02ffa000)return 1;
			u32 allowed = 0x02ffa000 - addr;
			if (len > allowed) return 1;

			if(addr>=BOOTLDR_NDS && addr<BOOTLDR_NDS+nds_size)return 1;
			allowed = BOOTLDR_NDS - addr;
			if (len > allowed) return 1;

			return 0;
		break;

		case 0x03:
			return 0;
		break;

		default:
			return 1;
		break;
	}
	return 0;
}

int read_nds()
{
	FATFS fat;
	FIL file;
	FILINFO info;
	FRESULT res = 0;
	u32 readlen = 0;
	u32 *buf = (u32*)BOOTLDR_NDS;

	memset(buf, 0, 0x200);
	res = f_mount(0, &fat);
	snprintf(fifo_string, 0xff, "f_mount returned: %d", res);
	SendFIFOString(NULL);
	if(res!=0)return (int)res;
	
	res = f_stat(NDSFN, &info);
	snprintf(fifo_string, 0xff, "f_stat returned: %d", res);
	SendFIFOString(NULL);
	if(res!=0)
	{
		SendFIFOString("Failed to stat " NDSFN ".");
		return (int)res;
	}

	nds_size = info.fsize;
	snprintf(fifo_string, 0xff, "nds filesize: %x", nds_size);
	SendFIFOString(NULL);
	*((u32*)(BOOTLDR_NDS-8)) = nds_size;
	if(BOOTLDR_NDS + nds_size >= 0x02ffa000)
	{
		SendFIFOString(NDSFN " is too large, max size is ~12.97MB.");
		return 1;
	}

	res = f_open(&file, NDSFN, FA_READ);
	snprintf(fifo_string, 0xff, "f_open returned: %d", res);
	SendFIFOString(NULL);
	if(res!=0)
	{
		SendFIFOString("Failed to open " NDSFN ".");
		return (int)res;
	}

	if(res==FR_OK)
	{
		SendFIFOString("Reading nds...");
		f_read(&file, buf, nds_size, &readlen);
		snprintf(fifo_string, 0xff, "f_read returned: %d", res);
		SendFIFOString(NULL);
		if(res!=0)return (int)res;

		snprintf(fifo_string, 0xff, "readlen: %x", readlen);
		SendFIFOString(NULL);
		f_close(&file);

		SendFIFOString("Reading done.");
		if((res = nds_crypto()))return res;
		if(memrange_check(BOOTLDR_NDSHEADER->arm9destination, BOOTLDR_NDSHEADER->arm9binarySize))return 1;
		if(memrange_check(BOOTLDR_NDSHEADER->arm7destination, BOOTLDR_NDSHEADER->arm7binarySize))return 1;
		if(memrange_check(BOOTLDR_TWLNDSHEADER->arm9idestination, BOOTLDR_TWLNDSHEADER->arm9ibinarySize))return 1;
		if(memrange_check(BOOTLDR_TWLNDSHEADER->arm7idestination, BOOTLDR_TWLNDSHEADER->arm7ibinarySize))return 1;

		#ifdef USELIBNDS
		fifoSendAddress(FIFO_USER_01, 0x544f42);
		while(!fifoCheckValue32(FIFO_USER_01));
		#else
		debugprint_done = 0;
		mininds_sendfifodata(FIFO_USER_01, 0x544f42);
		while(!debugprint_done)
		{
			swiWaitForVBlank();
			if(!debugprint_done)mininds_sendfifodata(FIFO_USER_01, 0x544f42);
		}
		#endif
	}
	return res;
}

u32 somebuf[0x80];
//---------------------------------------------------------------------------------
int main() {
//---------------------------------------------------------------------------------
	int retval = 0;
	int printi;

	#ifdef USELIBNDS
	readUserSettings();

	irqInit();
	fifoInit();
	#else
	irqInit();
	mininds_initfifo();
	#endif

	// Start the RTC tracking IRQ
	#ifdef USELIBNDS
	initClockIRQ();

	SetYtrigger(80);

	#ifdef WIFITWLDEBUG
	installWifiFIFO();
	#endif
	installSoundFIFO();

	installSystemFIFO();
	#endif

	#ifdef USELIBNDS
	irqSet(IRQ_VCOUNT, VcountHandler);
	irqSet(IRQ_VBLANK, VblankHandler);
	setPowerButtonCB(powerButtonCB);

	irqEnable( IRQ_VBLANK | IRQ_VCOUNT | IRQ_NETWORK);   
	#else
	irqEnable(IRQ_VBLANK);
	#endif

	memset(fifo_string, 0, 0x100);
	#ifdef TWLDEBUG
	mininds_setfifochanhandler(FIFO_USER_01, mini_printhandler);
	#endif

	#ifdef USETWLSDMMC
	retval = twlsdmmc_init(0);
	if(retval!=0)SendFIFOString("sdmmc init failed.");
	#endif
	#ifdef HWCRYPTO
	twlescrypt_init();
	#endif

	memset32((void*)BOOTLDR_NDS, 0xd00000-0xc000);

	if(!sdmmc_cardinserted())
	{
		SendFIFOString("Waiting for sdcard to be inserted and initialized...");
		while(sdmmc_sdcard_init())swiWaitForVBlank();
	}

	if(read_nds()!=0)
	{
		SendFIFOString("Failed to load nds.");
	}
	else
	{
		SendFIFOString("Done!");
	}

	// Keep the ARM7 mostly idle
	while (!exitflag) {
		if ( 0 == (REG_KEYINPUT & (KEY_SELECT | KEY_START | KEY_L | KEY_R))) {
			exitflag = true;
		}

		//ideally we would wait for irq here to keep from burning cpu.
		//but arm7 bios routines seem not to be readily available at this point.
		swiWaitForVBlank();
	}
	return 0;
}

