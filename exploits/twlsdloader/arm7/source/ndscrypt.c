#ifdef USELIBNDS
#include <nds.h>
#else
#include <mininds/mininds.h>
#endif
#include <nds/bios.h>
#include <string.h>
#include <stdio.h>

#ifndef HWCRYPTO
#include "dsi.h"
#else
#include <twlescrypt/twlescrypt.h>
#endif

#include "common.h"

#define KEY0_SRLDAT 0x37ded38
#define KEY0_SRLDATSZ 0x58

u8 static_key0[16] = {0xd8, 0xe2, 0xcc, 0x93, 0x06, 0x92, 0xf1, 0x49, 0x66, 0xa3, 0xa2, 0xde, 0x5c, 0xee, 0x94, 0x99};

extern u32 nds_size;

void swiSHA1(void* hash, void* msg, int sz);
void genkey(u8 *statickey, u8 *outkey, u32 *srldata, u32 srldatasz, int useserial)
{
	int i;
	u8 hash[20];
	u8 tempkey[16];
	u8 hashbuf[0x1c];
	memset(hash, 0, 20);

	swiSHA1(hash, srldata, srldatasz);
	for(i=0; i<16; i++)tempkey[i] = statickey[i] ^ hash[i];
	if(useserial)
	{
		memcpy(hashbuf, tempkey, 0x10);
		memcpy(&hashbuf[0x10], (void*)0x02fffd71, 0xc);//serial#
		swiSHA1(hash, hashbuf, 0x1c);
		memcpy(tempkey, hash, 0x10);
		memset(hashbuf, 0, 0x1c);
	}
	memcpy(outkey, tempkey, 0x10);
	memset(hash, 0, 20);
}

dsi_es_context cryptoctx;
unsigned char cryptheader[0x200];
unsigned char *escryptbuf = (unsigned char*)0x02400000;

int hashcmp(u8 *a, u8 *b)
{
	int i;
	for(i=0; i<20; i++)
	{
		if(a[i]!=b[i])return 1;
	}
	return 0;
}

int ndscrypto_checkserial()
{
	int retval = 0, i;
	u32 num_serials;
	u32 *serials = (u32*)BOOTLDR_NDSHEADER->zeros88[0];//header offset 0x88
	u8 my_hash[20];
	if(serials==NULL)return retval;
	retval = 1;
	serials = (u32*)((int)serials + BOOTLDR_NDS);
	num_serials = *serials;
	serials++;
	
	swiSHA1(my_hash, (void*)0x02fffd71, 0xc);//serial#
	for(i=0; i<num_serials; i++)
	{
		if(hashcmp(my_hash, (u8*)&serials[5*i])==0)
		{
			retval = 0;
			break;
		}
	}

	return retval;
}

int decrypt_nds()
{
	int tempsz = 0x200;
	int sz = nds_size - 0x220;
	int pos = 0x220;
	int decryptpos = 0x200;
	unsigned char metablock[0x20];
	memset(escryptbuf, 0, 0x200);

	while(sz>0x20)
	{
		if(sz<tempsz)tempsz = sz - 0x20;
		memcpy(escryptbuf, (void*)(BOOTLDR_NDS+pos), tempsz);
		memcpy(metablock, (void*)(BOOTLDR_NDS+pos+tempsz), 0x20);

		if(dsi_es_decrypt(&cryptoctx, escryptbuf, metablock, tempsz)<0)
		{
			return 1;
		}

		memcpy((void*)(BOOTLDR_NDS+decryptpos), escryptbuf, tempsz);
		sz-= tempsz+0x20;
		pos+= tempsz+0x20;
		decryptpos+= tempsz;
	}

	memset(escryptbuf, 0, 0x200);

	if(ndscrypto_checkserial())return 2;

	return 0;
}

int check_ndsencryption()
{
	int retval;
	unsigned char metablock[0x20];
	memset(cryptheader, 0, 0x200);
	memset(metablock, 0, 0x20);

	memcpy(cryptheader, (void*)BOOTLDR_NDS, 0x200);
	memcpy(metablock, (void*)(BOOTLDR_NDS+0x200), 0x20);

	retval = dsi_es_decrypt(&cryptoctx, cryptheader, metablock, 0x200);
	if(retval<0)
	{
		return 0;
	}

	memcpy((void*)BOOTLDR_NDS, cryptheader, 0x200);

	return 1;
}

int nds_crypto()
{
	int i;
	int retval = 0;
	u8 key0[16];

	memset(key0, 0, 16);
	
	genkey(static_key0, key0, (u32*)KEY0_SRLDAT, KEY0_SRLDATSZ, 0);
	#ifndef HWCRYPTO
	dsi_es_init(&cryptoctx, key0);
	#else
	dsi_es_init(&cryptoctx, key0, NULL, NULL);
	#endif
	memset(key0, 0, 16);
	if(check_ndsencryption())
	{
		memset(static_key0, 0, 16);
		memset((void*)KEY0_SRLDAT, 0, KEY0_SRLDATSZ);
		retval = decrypt_nds();
	}
	else
	{
		genkey(static_key0, key0, (u32*)KEY0_SRLDAT, KEY0_SRLDATSZ, 1);
		#ifndef HWCRYPTO
		dsi_es_init(&cryptoctx, key0);
		#else
		dsi_es_init(&cryptoctx, key0, NULL, NULL);
		#endif
		memset(key0, 0, 16);
		memset(static_key0, 0, 16);
		memset((void*)KEY0_SRLDAT, 0, KEY0_SRLDATSZ);
		if(check_ndsencryption())retval = decrypt_nds();
	}
	memset(&cryptoctx, 0, sizeof(dsi_es_context));

	for(i=2; i<4; i++)((vu32*)0x040044f0)[i] = 0x3941A4 * i+1 * i;//keyslot3 keyY last two words.
	while(*((vu32*)0x04004400) & (1<<25));//AES_WaitKey

	return retval;
}

