#include <stdint.h>
#include <openssl/sha.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * ./add_to_templates <full title id> <hash-of-tmd> <hash-of-banner> <hash-of-savedata> <ap-cert-filename> <template-file-to-update>
 *
 * the tmdhash is used as a key for entries- there can only be a single entry for each unique tmdhash
 *
 * can be invoked like:
 * ./add_to_templates 000300044b344456 4fae34f27164bdfaa9650f68811d007b3f4ea8e9 a78a580aef4fe5d1f00e1dc8f6dcbd4035a3477d 0011223344556677889900112233445566778899 ap_cert templates
 * or even:
 * ./add_to_templates 000300044b344456 4fae34f27164bdfaa9650f68811d007b3f4ea8e9 `sha1sum bannerfile | cut -f 1 -d ' '`  `sha1sum savefile | cut -f 1 -d ' '` ap_cert templates
 *
 *
 */

typedef uint8_t sha1_hash[0x14];
typedef struct ecc_point_t
{
	uint8_t r[0x1e];
	uint8_t s[0x1e];
} __attribute__((packed)) ecc_point_t;

typedef struct ecc_cert_t
{
	struct {
		uint32_t type;
		ecc_point_t val;
		uint8_t padding[0x40];
	} sig;
	char issuer[0x40];
	uint32_t key_type;
	char key_id[0x40];
	uint32_t unk;
	ecc_point_t pubkey;
	uint8_t padding2[0x3c];
} __attribute__((packed)) ecc_cert_t;

typedef struct footer_adjustment
{
	uint8_t title_id[8];
	sha1_hash tmd_hash;
	sha1_hash banner_hash;
	sha1_hash savedata_hash;
	ecc_cert_t ap_cert;
} __attribute__((packed)) footer_adjustment;


uint8_t title_id[8];
sha1_hash tmd_hash;
sha1_hash banner_hash;
sha1_hash savedata_hash;
ecc_cert_t ap_cert;
int i;
struct stat st;
int template_count = 0;
footer_adjustment *fa=NULL;

#ifndef DEBUG
void hex_dump(void *_src, int len)
{
	uint8_t *src = _src;
	int i;
	for(i = 0; i<len; i++)
	{
		printf("%02hhx", src[i]);
	}
}
#endif

int main(int argc, char *argv[])
{
	if(argc != 7)
	{
		printf("usage: %s titleid tmdhash bannerhash savehash apcertfile templatefile\n", argv[0]);
		return 1;
	}

	if(strlen(argv[1]) != 16)
	{
		printf("titleid not full\n");
		return 4;
	}
	for(i=0; i<8; i++)
	{
		if(sscanf(argv[1]+(i*2), "%02hhx", &title_id[i]) != 1)
		{
			printf("error parsing titleid\n");
			return 4;
		}
	}
	if(strlen(argv[2]) != 40)
	{
		printf("tmdhash not full\n");
		return 4;
	}
	for(i=0; i<20; i++)
	{
		if(sscanf(argv[2]+(i*2), "%02hhx", &tmd_hash[i]) != 1)
		{
			printf("error parsing tmdhash\n");
			return 4;
		}
	}

	if(strlen(argv[3]) != 40)
	{
		printf("bannerhash not full\n");
		return 5;
	}
	for(i=0; i<20; i++)
	{
		if(sscanf(argv[3]+(i*2), "%02hhx", &banner_hash[i]) != 1)
		{
			printf("error parsing bannerhash\n");
			return 5;
		}
	}
	if(strlen(argv[4]) != 40)
	{
		printf("savehash not full\n");
		return 6;
	}
	for(i=0; i<20; i++)
	{
		if(sscanf(argv[4]+(i*2), "%02hhx", &savedata_hash[i]) != 1)
		{
			printf("error parsing savehash\n");
			return 5;
		}
	}

	FILE *ap_cert_file = fopen(argv[5], "rb");
	if(ap_cert_file == NULL)
	{
		perror("could not fopen apcert:");
		return 6;
	}

	if(fstat(fileno(ap_cert_file), &st) != 0)
	{
		perror("could not fstat apcert:");
		fclose(ap_cert_file);
		return 6;
	}

	if(st.st_size != sizeof(ecc_cert_t))
	{
		printf("ap_cert is not correct size\n");
		fclose(ap_cert_file);
		return 6;
	}

	if(fread(&ap_cert, sizeof(ecc_cert_t), 1, ap_cert_file) != 1)
	{
		perror("could not read ap_cert");
		fclose(ap_cert_file);
		return 6;
	}

	fclose(ap_cert_file);

	// some sanity checks on ap_cert

	if(ap_cert.sig.type != 0x02000100)
	{
		printf("ap_cert sig type is weird\n");
	}
	if(ap_cert.key_type != 0x02000000)
	{
		printf("ap_cert key type is weird\n");
	}

	footer_adjustment *target_replacement = NULL;

	FILE *template_file = fopen(argv[6], "rb");
	if(template_file)
	{
		if(fstat(fileno(template_file), &st) != 0)
		{
			perror("fstat");
			fclose(template_file);
			return 2;
		}
		if(st.st_size % sizeof(footer_adjustment) != 0)
		{
			printf("template file is not a multiple of sizeof(footer_adjustment)\n");
			fclose(template_file);
			return 3;
		}

		template_count = st.st_size/sizeof(footer_adjustment);
		fa = malloc(st.st_size + sizeof(footer_adjustment));


		fread(fa, sizeof(footer_adjustment), template_count, template_file);
		for(i=0; i<template_count;i++)
		{
#ifdef DEBUG
			printf("fa[i].tmd_hash: ");
			hex_dump(&fa[i].tmd_hash[0], sizeof(sha1_hash));
			printf("\n");
			printf("tmd_hash: ");
			hex_dump(&tmd_hash[0], sizeof(sha1_hash));
			printf("\n");
#endif
			if(memcmp(fa[i].tmd_hash, tmd_hash, sizeof(sha1_hash)) == 0)
			{
				printf("replacing entry %d\n", i);
				target_replacement = &fa[i];
				break;
			}
		}
		if(i==template_count)
		{
			printf("appending entry\n");
			target_replacement = &fa[i];
			template_count++;
		}
	}
	else
	{
		printf("creating new file for entry\n");
		fa = malloc(sizeof(footer_adjustment));
		target_replacement = fa;
		template_count = 1;
	}


	memcpy(target_replacement->title_id, title_id, sizeof(title_id));
	memcpy(target_replacement->tmd_hash, tmd_hash, sizeof(sha1_hash));
	memcpy(target_replacement->banner_hash, banner_hash, sizeof(sha1_hash));
	memcpy(target_replacement->savedata_hash, savedata_hash, sizeof(sha1_hash));
	memcpy(&target_replacement->ap_cert, &ap_cert, sizeof(ecc_cert_t));

	FILE *output = fopen(argv[6], "wb");
	if(output == NULL)
	{
		perror("could not open output");
	}
	else
	{
		fwrite(fa, sizeof(footer_adjustment), template_count, output);
		fclose(output);
	}

	free(fa);

	return 0;
}
