#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <endian.h>
#include <string.h>
#include <sys/stat.h>

int main(int argc, char **argv)
{
	FILE *fsave;
	unsigned char *savebuf;
	unsigned int *temp;
	int i, cpi;
	int size = 0;
	unsigned int value, fill = 0x55555555;
	int xorbin = 0;
	int grtpwn = 0, num;
	struct stat binstats;
	unsigned int skipoff = 0x18a;

	if(argc<3)
	{
		return 0;
	}

	for(i=4; i<argc; i++)
	{
		if(strncmp(argv[i], "--xorbin", 8)==0)xorbin = 1;
		if(strncmp(argv[i], "--grtpwn", 8)==0)grtpwn = 1;
	}

	if(stat(argv[1], &binstats)==-1)printf("stat fail\n");
	if(xorbin || grtpwn)
	{
		size = binstats.st_size/4;
		if(size==0)
		{	
			printf("FAIL!\n");
			return 0;
		}
	}

	if(!xorbin && !grtpwn)fsave = fopen(argv[1], "w");
	if(xorbin || grtpwn)
	{
		fsave = fopen(argv[1], "r");
	}
	if(fsave==NULL)
	{
		printf("failed to open file.\n");
		return 0;
	}

	if(!xorbin && !grtpwn)sscanf(argv[2], "%x", &size);
	sscanf(argv[3], "%x", &value);
	value = htole32(value);
	savebuf = (unsigned char*)malloc(size*4);
	temp = (unsigned int*)savebuf;
	memset(savebuf, 0, size*4);
	if(xorbin || grtpwn)
	{
		i = fread(savebuf, 1, size*4, fsave);
		if(i!=size*4)
		{
			printf("read fail %x\n", i);
			fclose(fsave);
			free(savebuf);
			return 0;
		}
		fseek(fsave, 0, SEEK_SET);
		fclose(fsave);
		fsave = fopen(argv[1], "wb");
	}

	if(!grtpwn)
	{
		for(i=0; i<size; i++)
		{
			if(!xorbin)
			{
				temp[i] = value + (i*2);
				if((unsigned char)temp[i]==0)temp[i]++;
			}
			if(xorbin)temp[i] ^= value;
		}
	}

	if(grtpwn)
	{
		for(i=0x22; i<0x6a; i+=4)
		{
			if(0x6a-i>=4)
			{
				memcpy(&savebuf[i], &value, 4);
			}
			else
			{
				memcpy(&savebuf[i], &fill, 0x6a-i);
			}
		}
		for(i=0x6a; i<0x1e2; i+=4)
		{
			for(num=0; num<4; num++)
			{
				if(savebuf[i+num]!=0)break;
			}
			if(num)
			{
				memcpy(&savebuf[i], &value, num);
			}
		}
		for(i=0x49e - 0x10; i<0x49e + 0x178; i+=4)
		{
			for(num=0; num<4; num++)
			{
				if(savebuf[i+num]!=0)break;
			}
			if(num)
			{
				memcpy(&savebuf[i], &value, num);
			}
		}
	}

	fwrite(savebuf, 1, size*4, fsave);
	fclose(fsave);
	free(savebuf);

	return 0;
}

