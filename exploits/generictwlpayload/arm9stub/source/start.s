/*
	mini - a Free Software replacement for the Nintendo/BroadOn IOS.

	ELF loader: system startup

Copyright (C) 2008, 2009	Hector Martin "marcan" <marcan@marcansoft.com>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 2.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/

//Modified for nzoneurlstacksmash by yellowstar6.
.arm

.arch armv5te
.fpu softvfp
.eabi_attribute 23, 1
.eabi_attribute 24, 1
.eabi_attribute 25, 1
.eabi_attribute 26, 1
.eabi_attribute 30, 2
.eabi_attribute 18, 4

.extern _main
.extern __got_start
.extern __got_end
.extern __bss_start
.extern __bss_end
.globl _start
.global DC_FlushAll
.global DC_InvalidateAll
.global IC_InvalidateAll
.global memset32

.section .init

_start:
	@ Get real address of _start
	sub	r4, pc, #8
	@ Subtract offset to get the address that we were loaded at
	ldr	r0, =_start
	sub	r4, r4, r0

	@ relocate the GOT entries
	/*ldr	r1, =__got_start
	add	r1, r4
	ldr	r2, =__got_end
	add	r2, r4
got_loop:
	@ check for the end
	cmp	r1, r2
	beq	done_got
	@ read the GOT entry
	ldr	r3, [r1]
	@ add our base address
	add	r3, r4
	str	r3, [r1]
	@ move on
	add	r1, r1, #4
	b	got_loop

done_got:*/
	@ clear BSS
	ldr	r1, =__bss_start
	@add	r1, r4
	ldr	r2, =__bss_end
	@add	r2, r4
	mov	r3, #0
bss_loop:
	@ check for the end
	cmp	r1, r2
	beq	done_bss
	@ clear the word and move on
	str	r3, [r1]
	add	r1, r1, #4
	b	bss_loop

done_bss:
	@ take the plunge
	mov	r0, r4
	bl	main

	_start_dielp: @ Added by yellowstar6. This code should never be executed.
	b _start_dielp

.pool

#define DCACHE_SIZE	0x1000
#define CACHE_LINE_SIZE	32

.arm
DC_FlushAll: @ From libnds, write buffer draining code was added by yellowstar6.
/*---------------------------------------------------------------------------------
	Clean and invalidate entire data cache
---------------------------------------------------------------------------------*/
	mov	r1, #0
outer_loop:
	mov	r0, #0
inner_loop:
	orr	r2, r1, r0			@ generate segment and line address
	mcr	p15, 0, r2, c7, c14, 2		@ clean and flush the line
	add	r0, r0, #CACHE_LINE_SIZE
	cmp	r0, #DCACHE_SIZE/4
	bne	inner_loop
	add	r1, r1, #0x40000000
	cmp	r1, #0
	@bne	outer_loop
	mov r0, #0
	mcr 15, 0, r0, cr7, cr10, 4 @ Drain write buffer.
	bx	lr

//---------------------------------------------------------------------------------
	.global DC_FlushRange
//---------------------------------------------------------------------------------
DC_FlushRange:
/*---------------------------------------------------------------------------------
	Clean and invalidate a range
---------------------------------------------------------------------------------*/
	add	r1, r1, r0
	bic	r0, r0, #(CACHE_LINE_SIZE - 1)
.flush:
	mcr	p15, 0, r0, c7, c14, 1		@ clean and flush address
	add	r0, r0, #CACHE_LINE_SIZE
	cmp	r0, r1
	blt	.flush
	bx	lr


IC_InvalidateAll: @ From libnds.
/*---------------------------------------------------------------------------------
	Clean and invalidate entire data cache
---------------------------------------------------------------------------------*/
	mov	r0, #0
	mcr	p15, 0, r0, c7, c5, 0
	bx	lr

DC_InvalidateAll:
mov r0, #0
mcr 15, 0, r0, cr7, cr6
bx lr

memset32:
push {r0-r9}
mov r8, r0
add r1, r1, r0
mov r9, r1

mov r0, #0
mov r1, r0
mov r2, r0
mov r3, r0
mov r4, r0
mov r5, r0
mov r6, r0
mov r7, r0

memset32_lp:
stmia r8!, {r0-r7}
sub r0, r9, r8
@cmp r8, r9
cmp r0, #0x20
mov r0, #0
bge memset32_lp
cmp r9, r8
beq memset32_end

memset32_wordlp:
str r0, [r8], #4
cmp r8, r9
blt memset32_wordlp

memset32_end:
pop {r0-r9}
bx lr

